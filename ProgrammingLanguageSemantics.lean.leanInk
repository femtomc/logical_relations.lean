[{"contents":"import Init.Prelude\nimport Mathlib.Data.Nat.Basic\nimport Lean\n\n/-!\nThis is a tutorial file showing the usage of logical relations to prove properties about languages, including things like soundness of a type system, and even soundness of a denotational semantics.\n\nFirst, we'll start by considering a simple language with arithmetic, and function definitions.\n-/\n\ninductive Term\n| Nat : ℕ → Term\n| Var : ℕ → Term\n| Prim : (ℕ → ℕ → ℕ) → Term\n| Abs : Term → Term\n| App : Term → Term → Term\n\ndef termRepr : Term → Nat → Lean.Format\n| Term.Nat n, _ => repr n\n| Term.Var n, _ => \"var(\" ++ repr n ++ \")\"\n| Term.Prim _, _ => \"<opaque prim>\"\n| Term.Abs t, depth => \"(λ \" ++ termRepr t (depth + 1) ++ \")\"\n| Term.App t1 t2, depth => \"(\" ++ termRepr t1 (depth + 1) ++ \" \" ++ termRepr t2 (depth + 1) ++ \")\"\n\ninstance : Repr Term where\nreprPrec t _ := termRepr t 0\n\ndef Env := List Term\n\ndef lookupEnv : Env -> ℕ -> Option Term\n| [], _ => none\n| (v :: _), 0 => some v\n| (_ :: vs), (n + 1) => lookupEnv vs n\n\ndef shift : ℕ -> Term -> Term\n| _, Term.Nat n => Term.Nat n\n| d, Term.Var k => Term.Var (k + d)\n| d, Term.Abs t => Term.Abs (shift (d + 1) t)\n| d, Term.App t1 t2 => Term.App (shift d t1) (shift d t2)\n| _, Term.Prim f => Term.Prim f\n\ndef subst : ℕ -> Term -> Term -> Term\n| _, _, Term.Nat n => Term.Nat n\n| k, s, t@(Term.Var k') => if k = k' then s else t\n| k, s, Term.Abs t => Term.Abs (subst (k + 1) (shift 1 s) t)\n| k, s, Term.App t1 t2 => Term.App (subst k s t1) (subst k s t2)\n| _, _, t@(Term.Prim _) => t\n\ndef eval : ℕ -> Env → Term → Term\n| 0, _, t@(_) => t\n| _, _, Term.Nat n => Term.Nat n\n| _, env, Term.Var n => (lookupEnv env n).getD (Term.Var n)\n| fuel + 1, env, Term.Abs t => Term.Abs (eval fuel (Term.Var 0 :: env.map (shift 1)) t)\n| _, _, Term.Prim f => Term.Prim f\n| fuel + 1, env, (Term.App (Term.Abs t) v) =>\n  let v_eval := eval fuel env v; \n  eval fuel env (subst 0 v_eval t) \n| fuel + 1, env, (Term.App t1 t2) =>\n  let t1_eval := eval fuel env t1;\n  let t2_eval := eval fuel env t2;\n  eval fuel env (Term.App t1_eval t2_eval)\n\n","_type":"text"},{"messages":[{"contents":"5\n","_type":"message"}],"goals":[],"contents":"#eval","_type":"sentence"},{"contents":" eval 10 [] (Term.App (Term.Abs (Term.Var 0)) (Term.Nat 5))\n","_type":"text"}]